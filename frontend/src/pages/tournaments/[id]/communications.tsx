import {
  Badge,
  Button,
  Card,
  Checkbox,
  Group,
  Select,
  Stack,
  Text,
  TextInput,
  Textarea,
  Title,
} from '@mantine/core';
import { showNotification } from '@mantine/notifications';
import { useEffect, useMemo, useState } from 'react';

import RequestErrorAlert from '@components/utils/error_alert';
import MarkdownContent from '@components/utils/markdown';
import { getTournamentIdFromRouter } from '@components/utils/util';
import Layout from '@pages/_layout';
import TournamentLayout from '@pages/tournaments/_tournament_layout';
import {
  getLeagueAdminUsers,
  getLeagueCommunications,
  getTournaments,
} from '@services/adapter';
import {
  createLeagueCommunication,
  deleteLeagueCommunication,
  updateLeagueCommunication,
} from '@services/league';

function formatDate(value: string | null | undefined) {
  if (value == null || value === '') return '-';
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return value;
  return date.toLocaleString();
}

const SUGGESTED_RULE_TITLE = 'League Rules & Player Guide';
const SUGGESTED_RULE_BODY = `## Core Rules

1. Be respectful to opponents and admins. Unsportsmanlike behavior can result in warnings, match loss, or removal.
2. Submit a legal deck before entering events or reporting scores.
3. Use the posted schedule windows. Contact your opponent early if you need to reschedule.
4. For regular season matchups, pairings are generated by the schedule and should be played as listed.
5. Enter results promptly after matches so standings and next pairings stay accurate.
6. If a match is played on Karabast, both players must use the same lobby/game name and correct deck export.
7. Event-specific formats (Swiss, Round Robin, Single/Double Elimination) are set by the event stage and must be followed.
8. Admin rulings are final for disputes, deck legality issues, and reporting corrections.

## Player Guide: How To Use The Site

1. Read **Announcements** and **League Rules** first for current policy updates.
2. Open **Schedule** and filter by your season/player to find your next matches.
3. Build and save decks in **Deckbuilder**. Keep your main deck updated before events.
4. Go to **Entries** for the event and submit/apply with the deck you want to play.
5. Play your scheduled match(es). If needed, use **Base Health** as a game aid.
6. After playing, report/confirm match scores in the event workflow so standings update.
7. Track progress in **Standings**, and review **Players** / **Meta** pages for league stats.

## Match Scheduling Notes

- Regular season may schedule multiple games vs the same opponent in the same week.
- Games per opponent and games per matchup week are controlled by the schedule setup.
- If you cannot play in the posted window, message your opponent and admin as early as possible.

## Deck & Event Notes

- Deck submission is required before playing or score entry when enforced by the event.
- If an admin opens/closes events or changes stage status, follow the latest posted status.
- Use one clear player name across deck submissions and entries to avoid mismatches.
`;

export default function CommunicationsPage({ standalone = false }: { standalone?: boolean }) {
  const { tournamentData } = getTournamentIdFromRouter();
  const swrTournamentsResponse = getTournaments('ALL');
  const tournaments = swrTournamentsResponse.data?.data ?? [];
  const [selectedTournamentId, setSelectedTournamentId] = useState<string | null>(null);

  useEffect(() => {
    if (!standalone || tournaments.length < 1 || selectedTournamentId != null) return;
    const saved = window.localStorage.getItem('league_default_tournament_id');
    const selected = tournaments.find((t: any) => String(t.id) === saved) ?? tournaments[0];
    setSelectedTournamentId(String(selected.id));
    window.localStorage.setItem('league_default_tournament_id', String(selected.id));
  }, [standalone, tournaments, selectedTournamentId]);

  const activeTournamentId = standalone
    ? Number(selectedTournamentId ?? tournaments[0]?.id ?? 0)
    : tournamentData.id;

  const swrCommunicationsResponse = getLeagueCommunications(activeTournamentId);
  const swrAdminUsersResponse = getLeagueAdminUsers(activeTournamentId);
  const isAdmin = swrAdminUsersResponse.data != null;

  const rows = useMemo(
    () => swrCommunicationsResponse.data?.data ?? [],
    [swrCommunicationsResponse.data]
  );
  const announcements = rows.filter((row: any) => row.kind === 'ANNOUNCEMENT');
  const rules = [...rows]
    .filter((row: any) => row.kind === 'RULE')
    .sort((left: any, right: any) => {
      const leftTime = new Date(left.updated ?? 0).getTime();
      const rightTime = new Date(right.updated ?? 0).getTime();
      return rightTime - leftTime;
    });
  const notes = rows.filter((row: any) => row.kind === 'NOTE');
  const primaryRule = rules[0] ?? null;

  const [editingId, setEditingId] = useState<number | null>(null);
  const [kind, setKind] = useState<'NOTE' | 'ANNOUNCEMENT'>('ANNOUNCEMENT');
  const [title, setTitle] = useState('');
  const [body, setBody] = useState('');
  const [pinned, setPinned] = useState(false);
  const [ruleBody, setRuleBody] = useState('');
  const [ruleTitle, setRuleTitle] = useState(SUGGESTED_RULE_TITLE);

  useEffect(() => {
    if (primaryRule == null) {
      setRuleBody(SUGGESTED_RULE_BODY);
      setRuleTitle(SUGGESTED_RULE_TITLE);
      return;
    }
    setRuleBody(String(primaryRule.body ?? ''));
    setRuleTitle(String(primaryRule.title ?? SUGGESTED_RULE_TITLE));
  }, [primaryRule?.id, primaryRule?.body, primaryRule?.title]);

  const resetForm = () => {
    setEditingId(null);
    setKind('ANNOUNCEMENT');
    setTitle('');
    setBody('');
    setPinned(false);
  };

  const startEdit = (row: any) => {
    if (row.kind !== 'NOTE' && row.kind !== 'ANNOUNCEMENT') {
      return;
    }
    setEditingId(Number(row.id));
    if (row.kind === 'NOTE' || row.kind === 'ANNOUNCEMENT') {
      setKind(row.kind);
    } else {
      setKind('ANNOUNCEMENT');
    }
    setTitle(String(row.title ?? ''));
    setBody(String(row.body ?? ''));
    setPinned(Boolean(row.pinned));
  };

  const content = (
    <Stack>
      <Title>League Notes, Rules & Announcements</Title>
      <Text c="dimmed">
        League-wide rules, notes, and commissioner announcements for players and admins.
      </Text>

      {swrCommunicationsResponse.error && (
        <RequestErrorAlert error={swrCommunicationsResponse.error} />
      )}

      {isAdmin && (
        <Card withBorder>
          <Stack>
            <Title order={4}>{editingId == null ? 'New Announcement / Note' : 'Edit Message'}</Title>
            <Select
              label="Type"
              value={kind}
              allowDeselect={false}
              data={[
                { value: 'ANNOUNCEMENT', label: 'Announcement' },
                { value: 'NOTE', label: 'League Note' },
              ]}
              onChange={(value) =>
                setKind(
                  value === 'NOTE' || value === 'ANNOUNCEMENT'
                    ? value
                    : 'ANNOUNCEMENT'
                )
              }
            />
            <TextInput
              label="Title"
              value={title}
              onChange={(event) => setTitle(event.currentTarget.value)}
              placeholder="Weekly league update"
            />
            <Textarea
              label="Message"
              value={body}
              minRows={4}
              onChange={(event) => setBody(event.currentTarget.value)}
              placeholder="Markdown supported. Mentions like @username and #event will be highlighted."
            />
            <Checkbox
              label="Pin message"
              checked={pinned}
              onChange={(event) => setPinned(event.currentTarget.checked)}
            />
            <Group>
              <Button
                onClick={async () => {
                  if (activeTournamentId <= 0 || title.trim() === '' || body.trim() === '') return;
                  if (editingId == null) {
                    await createLeagueCommunication(activeTournamentId, {
                      kind,
                      title: title.trim(),
                      body: body.trim(),
                      pinned,
                    });
                    showNotification({
                      color: 'green',
                      title: 'Message created',
                      message: '',
                    });
                  } else {
                    await updateLeagueCommunication(activeTournamentId, editingId, {
                      kind,
                      title: title.trim(),
                      body: body.trim(),
                      pinned,
                    });
                    showNotification({
                      color: 'green',
                      title: 'Message updated',
                      message: '',
                    });
                  }
                  resetForm();
                  await swrCommunicationsResponse.mutate();
                }}
              >
                {editingId == null ? 'Save Message' : 'Update Message'}
              </Button>
              {editingId != null && (
                <Button variant="light" onClick={resetForm}>
                  Cancel
                </Button>
              )}
            </Group>
          </Stack>
        </Card>
      )}

      {isAdmin && (
        <Card withBorder>
          <Stack>
            <Title order={4}>League Rules (Single Markdown Block)</Title>
            <TextInput
              label="Rule Block Title"
              value={ruleTitle}
              onChange={(event) => setRuleTitle(event.currentTarget.value)}
              placeholder="League Rules"
            />
            <Textarea
              label="Rules Markdown"
              value={ruleBody}
              autosize
              minRows={8}
              maxRows={32}
              styles={{ input: { resize: 'vertical' } }}
              onChange={(event) => setRuleBody(event.currentTarget.value)}
              placeholder="Write all league rules in one markdown block."
            />
            <Group>
              <Button
                variant="light"
                onClick={() => {
                  setRuleTitle(SUGGESTED_RULE_TITLE);
                  setRuleBody(SUGGESTED_RULE_BODY);
                }}
              >
                Load Suggested Rules & Player Guide
              </Button>
              <Button
                onClick={async () => {
                  if (activeTournamentId <= 0 || ruleBody.trim() === '') return;
                  if (primaryRule == null) {
                    await createLeagueCommunication(activeTournamentId, {
                      kind: 'RULE',
                      title: ruleTitle.trim() === '' ? SUGGESTED_RULE_TITLE : ruleTitle.trim(),
                      body: ruleBody.trim(),
                      pinned: false,
                    });
                  } else {
                    await updateLeagueCommunication(activeTournamentId, Number(primaryRule.id), {
                      kind: 'RULE',
                      title: ruleTitle.trim() === '' ? SUGGESTED_RULE_TITLE : ruleTitle.trim(),
                      body: ruleBody.trim(),
                      pinned: false,
                    });
                    const duplicateRules = rules.slice(1);
                    await Promise.all(
                      duplicateRules.map((duplicate: any) =>
                        deleteLeagueCommunication(activeTournamentId, Number(duplicate.id))
                      )
                    );
                  }
                  showNotification({
                    color: 'green',
                    title: 'Rules updated',
                    message: '',
                  });
                  await swrCommunicationsResponse.mutate();
                }}
              >
                Save Rules
              </Button>
            </Group>
          </Stack>
        </Card>
      )}

      <Card withBorder>
        <Title order={4} mb="sm">
          Announcements
        </Title>
        <Stack>
          {announcements.length < 1 && (
            <Text c="dimmed" size="sm">
              No announcements yet.
            </Text>
          )}
          {announcements.map((row: any) => (
            <Card key={`announcement-${row.id}`} withBorder>
              <Group justify="space-between" mb={6}>
                <Group>
                  <Text fw={700}>{row.title}</Text>
                  {row.pinned ? <Badge color="yellow">Pinned</Badge> : null}
                </Group>
                {isAdmin && (
                  <Group gap={8}>
                    <Button size="xs" variant="light" onClick={() => startEdit(row)}>
                      Edit
                    </Button>
                    <Button
                      size="xs"
                      color="red"
                      variant="light"
                      onClick={async () => {
                        await deleteLeagueCommunication(activeTournamentId, Number(row.id));
                        await swrCommunicationsResponse.mutate();
                      }}
                    >
                      Delete
                    </Button>
                  </Group>
                )}
              </Group>
              <MarkdownContent text={row.body} />
              <Text mt="xs" size="xs" c="dimmed">
                {row.created_by_user_name ?? 'League admin'} | Updated {formatDate(row.updated)}
              </Text>
            </Card>
          ))}
        </Stack>
      </Card>

      <Card withBorder>
        <Title order={4} mb="sm">
          League Rules
        </Title>
        <Stack>
          {primaryRule == null && (
            <Text c="dimmed" size="sm">
              Using suggested rules template. Admins can edit and save this block.
            </Text>
          )}
          <Card key={`rule-${primaryRule?.id ?? 'suggested-template'}`} withBorder>
              <Group justify="space-between" mb={6}>
                <Group>
                  <Text fw={700}>{primaryRule?.title ?? SUGGESTED_RULE_TITLE}</Text>
                  {primaryRule == null ? <Badge color="blue">Template</Badge> : null}
                </Group>
                {isAdmin && primaryRule != null && (
                  <Group gap={8}>
                    <Button
                      size="xs"
                      color="red"
                      variant="light"
                      onClick={async () => {
                        await deleteLeagueCommunication(activeTournamentId, Number(primaryRule.id));
                        await swrCommunicationsResponse.mutate();
                      }}
                    >
                      Delete
                    </Button>
                  </Group>
                )}
              </Group>
              <MarkdownContent text={primaryRule?.body ?? SUGGESTED_RULE_BODY} />
              {primaryRule != null ? (
                <Text mt="xs" size="xs" c="dimmed">
                  {primaryRule.created_by_user_name ?? 'League admin'} | Updated {formatDate(primaryRule.updated)}
                </Text>
              ) : null}
            </Card>
          {rules.length > 1 ? (
            <Text size="xs" c="dimmed">
              {rules.length - 1} duplicate rule block(s) exist from older entries; saving rules will consolidate to one.
            </Text>
          ) : null}
        </Stack>
      </Card>

      <Card withBorder>
        <Title order={4} mb="sm">
          League Notes
        </Title>
        <Stack>
          {notes.length < 1 && (
            <Text c="dimmed" size="sm">
              No notes yet.
            </Text>
          )}
          {notes.map((row: any) => (
            <Card key={`note-${row.id}`} withBorder>
              <Group justify="space-between" mb={6}>
                <Group>
                  <Text fw={700}>{row.title}</Text>
                  {row.pinned ? <Badge color="yellow">Pinned</Badge> : null}
                </Group>
                {isAdmin && (
                  <Group gap={8}>
                    <Button size="xs" variant="light" onClick={() => startEdit(row)}>
                      Edit
                    </Button>
                    <Button
                      size="xs"
                      color="red"
                      variant="light"
                      onClick={async () => {
                        await deleteLeagueCommunication(activeTournamentId, Number(row.id));
                        await swrCommunicationsResponse.mutate();
                      }}
                    >
                      Delete
                    </Button>
                  </Group>
                )}
              </Group>
              <MarkdownContent text={row.body} />
              <Text mt="xs" size="xs" c="dimmed">
                {row.created_by_user_name ?? 'League admin'} | Updated {formatDate(row.updated)}
              </Text>
            </Card>
          ))}
        </Stack>
      </Card>
    </Stack>
  );

  if (standalone) {
    return <Layout>{content}</Layout>;
  }

  return <TournamentLayout tournament_id={tournamentData.id}>{content}</TournamentLayout>;
}
